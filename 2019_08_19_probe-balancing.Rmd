---
title: "Probe Balancing"
output: html_notebook
---

I need to determine how to balance the probe sets I return based on the number of probes per target. For a goal of N probes per target, I want to trim the number of probes for targets with greater than N probes, and I want to gradually relax the parameters for targets with less than N probes in an attempt to cover them.

I will be working with a probe-target intersection data frame. But all of this code should work the same on a data frame with the same rows.

```{r}
library(tidyverse)
```

```{r}
probes <- read_delim("/Users/hershe/Documents/OligoServer/probe_dbs/refseq_hg38_DNA-FISH_DB.csv",
                     col_names = c("chrom", "start", "stop", 
                                   "sequence", "Tm", "on_target",
                                   "off_target", "repeat", "max-kmer",
                                   "refseq"),
                     delim = "\t")

probes <- head(probes, 1000)
```

I'll test with a subset of the probe data frame.
```{r}
head(probes)
```

```{r}
example_top_n <- probes %>%
  group_by(refseq) %>%
  filter(n() >= 10) %>%
  top_n(-20, off_target) %>%
  ungroup()

example_top_n
```

The cell above returns the groups with greater than or equal to the goal number, and then trims them to the intended amount.

Now I need to handle the targets with less probes than the intended value.

```{r}
less_than <- probes %>%
  group_by(refseq) %>%
  filter(n() < 10)

targets_less_than <- unique(less_than$refseq)

add_back <- probes %>%
  filter(refseq %in% targets_less_than) %>%
  group_by(refseq) %>%
  top_n(-20, off_target) %>%
  ungroup()
  
```

My approach is in the cell above. First, I'll grab the IDs of the targets with less probes than the goal. Then I'll select out these targets from my pre-filtered intersect result in the app. Then I'll take the top_n() from the unfiltered set, again ranked by off_target value.

After experimenting with this in the Shiny app, I realized I needed to make some changes. top_n() returns more than N values if there are ties. I switched to sorting the values in each group by off_target, and then taking the top N values using slice. Here is what this looks like:
```{r}
example_top_n <- probes %>%
  group_by(refseq) %>%
  filter(n() >= 10) %>%
  arrange(off_target, .by_group = TRUE) %>%
  slice(1:20)

example_top_n
```

When doing the same operation for coordinate targets rather than refseq targets, I need to make a modification.
```{r}
probes %>%
  group_by(chrom, start) %>%
  mutate(target = str_c(chrom, start))
```



